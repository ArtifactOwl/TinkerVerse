use tokio::{net::TcpListener, time::{interval, Duration}};
use tokio_tungstenite::{accept_hdr_async, tungstenite::handshake::server::{Request, Response}};
use tokio_tungstenite::tungstenite::Message;
use futures::StreamExt;
use anyhow::Result;
use flatbuffers::{FlatBufferBuilder, WIPOffset};

use crate::{ecs::World, fixed::{TICK_HZ, to_f64, V3}, sim::{self, InputFrame}, types::{Kind, EntityId}};

// Generated by `flatc --rust -o server/src protocol/astral.fbs protocol/world.fbs`
use crate::astral_generated::astral as pb;

fn build_snapshot<'a>(fbb: &mut FlatBufferBuilder<'a>, world: &World, tick: u32) -> WIPOffset<pb::Snapshot<'a>> {
    let bodies = world.bodies.read();
    let mut estates: Vec<WIPOffset<pb::EntityState>> = Vec::with_capacity(bodies.len());
    for b in bodies.values() {
        let pos = pb::Vec3::new(to_f64(b.pos.x) as f32, to_f64(b.pos.y) as f32, to_f64(b.pos.z) as f32);
        let vel = pb::Vec3::new(to_f64(b.vel.x) as f32, to_f64(b.vel.y) as f32, to_f64(b.vel.z) as f32);
        let rot = pb::Quat::new(0.0,0.0,0.0,1.0);
        let scale = pb::Vec3::new(1.0,1.0,1.0);
        let mut esb = pb::EntityStateBuilder::new(fbb);
        esb.add_id(b.id);
        esb.add_kind(match b.kind { Kind::Ship=>pb::EntityKind::Ship, Kind::Projectile=>pb::EntityKind::Projectile, _=>pb::EntityKind::Unknown });
        esb.add_pos(&pos);
        esb.add_vel(&vel);
        esb.add_rot(&rot);
        esb.add_scale(&scale);
        esb.add_visual_id(0);
        esb.add_hp(to_f64(b.hp) as f32);
        estates.push(esb.finish());
    }
    let ents = fbb.create_vector(&estates);
    let mut sb = pb::SnapshotBuilder::new(fbb);
    sb.add_tick(tick);
    sb.add_entities(ents);
    sb.add_checksum(0);
    sb.finish()
}

pub async fn run(world: World) -> Result<()> {
    let listener = TcpListener::bind(("127.0.0.1", 8080)).await?;
    println!("astral-server (FB) listening ws://127.0.0.1:8080");

    let (stream, _addr) = listener.accept().await?;
    let ws = accept_hdr_async(stream, |_req: &Request, resp: Response| Ok(resp)).await?;
    let (mut ws_tx, mut ws_rx) = ws.split();

    // Spawn a ship
    let my_ship_id: EntityId = {
        let bodies = world.bodies.read();
        if let Some((_, b)) = bodies.iter().find(|(_, b)| matches!(b.kind, Kind::Ship)) { b.id } else { 0 }
    };
    let my_ship_id = if my_ship_id == 0 { world.spawn_ship() } else { my_ship_id };

    // Send a minimal Welcome as FlatBuffers binary (type=Welcome not tagged; this demo just sends Snapshot on each tick)
    let mut queue: Vec<InputFrame> = Vec::new();
    let mut tick: u32 = 0;
    let mut ticker = interval(Duration::from_millis((1000 / TICK_HZ) as u64));
    loop {
        tokio::select! {
            _ = ticker.tick() => {
                tick = tick.wrapping_add(1);
                sim::step(&world, &queue);
                queue.clear();

                let mut fbb = FlatBufferBuilder::new();
                let snap = build_snapshot(&mut fbb, &world, tick);
                fbb.finish(snap, None);
                let data = fbb.finished_data().to_vec();
                let _ = ws_tx.send(Message::Binary(data)).await;
            }
            msg = ws_rx.next() => {
                match msg {
                    Some(Ok(m)) => {
                        if m.is_binary() {
                            // Expect Input table (not tagged); parse if needed later.
                            let _bytes = m.into_data();
                            // For brevity, input parsing is left as an exercise in this stub.
                        }
                    }
                    _ => break
                }
            }
        }
    }
}
